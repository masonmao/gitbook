# 二叉树

## 二叉树的遍历方式

二叉树的遍历有三种，分别是前序遍历、中序遍历和后序遍历，我们来看看这三种遍历的特性：

- 前序遍历（根-->左-->右）


    1.访问根节点
    2.前序遍历左子树 
    3.前序遍历右子树

-  中序遍历（左-->根-->右）     


    1.中序遍历左子树
    2.访问根节点
    3.中序遍历右子树

- 
  后序遍历（左-->右-->根）


    1.后序遍历左子树
    2.后序遍历右子树
    3.访问根节点
## 已知两种遍历方式求第三种

### 已知前序、中序遍历，求后序遍历

前序遍历: ABGDECFH

中序遍历: GBEDAFCH

构建二叉树步骤：

1. 根据前序遍历的特点，我们知道根结点root为A；
2. 观察中序遍历GBEDAFCH。其中root节点A的左侧GBED必然是root的左子树，右侧FCH必然是root的右子树。同时，这个也分别是左子树和右子树的中序遍历的序列；
3. 在前序遍历遍历完根节点后，接着执行前序遍历左子树，注意，是前序遍历，什么意思？就是把左子树当成一棵独立的树，执行前序遍历，同样先访问左子树的根，第2步我们已经知道左子树是BGDE（前序遍历序列）了，由此可以得到，左子树的根是B，那么在这一步得到左子树的根是B；
4. 从第2步得到的中序遍历的节点序列中，找到B，发现B左边只有一个G，说明B的左子树只有一个叶子节点，B的右边呢？我们可以得到B的右子树有ED，再看前序遍历的序列，发现D在前，也就是说，D是先前序遍历访问的，则得到E是D的左子树，只有一个叶子节点。到这里，我们可以得到这棵树的根结点和左子树的结构了，如下图：
   ![img](https://img-blog.csdn.net/20180914113123828?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0MTU0NTcw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

5. 接着看右子树，在第2步的时候已经知道右子树是**FCH**这三个节点，那么先看前序遍历的序列，先出现的是**C****，**那么**C**就是右子树的根结点，看右子树的中序遍历为**FCH****，**所以**F**和**H**就分别是它的左子树和右子树，因此，右子树的结构就出来了，如下图：

   ![img](https://img-blog.csdn.net/20180914113308656?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0MTU0NTcw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

6. 把左子树和右子树连接起来，可以得到整棵树的结构：

   ![img](https://img-blog.csdn.net/2018091411333656?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0MTU0NTcw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

7. 最后由二叉树的结构可以得到后序遍历序列为：**GEDBFHCA**

代码示例如下：

```php
class TreeNode{
    var $val;
    var $left = NULL;
    var $right = NULL;
    function __construct($val){
        $this->val = $val;
    }
}

function reConstructBinaryTree(array $pre, array $vin)
{
	// write code here
	if (empty($pre) || empty($vin)){
		return;
	}

	$root = new TreeNode($pre[0]);

	$index = 0;
	for (; $index < count($pre); $index++){
		if ($pre[$index] == $vin[$index]){
			break;
		}
	}

	$pre1 = array_slice($pre, 1, $index);
	$vin1 = array_slice($vin, 0, $index);

	$pre2 = array_slice($pre, $index+1);
	$vin2 = array_slice($vin, $index+1);

	$root->left = reConstructBinaryTree($pre1, $vin1);
	$root->right = reConstructBinaryTree($pre2, $vin2);

	return $root;
}
```

# 已知中序、后序遍历，求前序遍历

中序遍历: GBEDAFCH

后序遍历：GEDBFHCA

步骤和上面的类似，还是得先找出根结点，由后序遍历的特点，根结点root在最后，所以根结点为**A****，**再由中序遍历可以知道左子树和右子树分别为****GBED**和**FCH**再按照上面的步骤递归分别求出左右子树即可得解。

代码如下：

```php
function reConstructBinaryTreeV2(array $vin, array $back)
{
	// write code here
	if (empty($vin) || empty($back)){
		return;
	}

	$rootVal = $back[count($back)-1];
	$root = new TreeNode($rootVal);

	$index = 0;
	for (; $index < count($vin); $index++){
		if ($rootVal == $vin[$index]){
			break;
		}
	}

	$vin1 = array_slice($vin, 0, $index);
	$back1 = array_slice($back, 0, $index);

	$vin2 = array_slice($vin, $index+1);
	$back2 = array_slice($back, $index, count($back)-$index-1);

	$root->left = reConstructBinaryTreeV2($vin1, $back1);
	$root->right = reConstructBinaryTreeV2($vin2, $back2);

	return $root;
}
```



# 已知前序、后序遍历，求中序遍历

已知**前序、中序**或者**中序、后序**都可以唯一确定一棵二叉树，但是已知前序、后序是无法唯一确定一棵二叉树的，解不唯一。


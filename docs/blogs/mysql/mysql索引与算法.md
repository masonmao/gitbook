# mysql索引

[TOC]



## 1. 索引概述

### 什么是索引

​		MySQL官方对索引的定义为：索引(Index)是帮助MySQL高效获取数据的数据结构。我们可以简单理解为：**快速查找排好序的一种数据结构。**Mysql索引主要有两种结构：B+Tree索引和Hash索引。我们平常所说的索引，如果没有特别指明，一般都是指B树结构组织的索引(B+Tree索引)。

### 为什么使用索引

​		使用索引主要是为了提高数据检索的效率。MySQL在300万条记录左右性能开始逐渐下降，虽然官方文档说500~800w记录，所以大数据量建立索引是非常有必要的。

## 2. 数据结构与算法

### 二分查找法

​    **二分查找操作的数据集是一个有序的数据集**。开始时，先找出有序集合中间的那个元素。如果此元素比要查找的元素大，就接着在较小的一个半区进行查找；反之，如果此元素比要找的元素小，就在较大的一个半区进行查找。在每个更小的数据集中重复这个查找过程，直到找到要查找的元素或者数据集不能再分割。

​		**二分查找能应用于任何类型的数据，只要能将这些数据按照某种规则进行排序**。然而，正因为它依赖于一个有序的集合，这使得它在处理那些频繁插入和删除操作的数据集时不太高效。这是因为，对于插入和操作来说，为了保证查找过程正常进行，必须保证数据集始终有序。相对于查找来说，维护一个有序数据集的代价更高。此外，元素必须存储在连续的空间中。**因此，当待搜索的集合是相对静态的数据集时，此时使用二分查找是最好的选择**。

#### 二分查找实现与分析

​		**二分查找法实质上是不断地将有序数据集进行对半分割，并检查每个分区的中间元素**。在以下介绍的实现方法中，有序数据集存放在sorted中，sorted是一块连续的存储空间。参数target是要查找的数据。

​		此实现过程的实施是通过变量left和right控制一个循环来查找元素（其中left和right是正在查找的数据集的两个边界值）。首先，将left和right分别设置为0和size-1。在循环的每次迭代过程中，将middle设置为left和right之间区域的中间值。如果处于middle的元素比目标值小，将左索引值移动到middle后的一个元素的位置上。即下一组要搜索的区域是当前数据集的上半区。如果处于middle的元素比目标元素大，将右索引值移动到middle前一个元素的位置上。即下一组要搜索的区域是当前数据集的下半区。随着搜索的不断进行，left从左向右移，right从右向左移。一旦在middle处找到目标，查找将停止；如果没有找到目标，left和right将重合。下图显示了此过程。

![img](https://images2018.cnblogs.com/blog/1281268/201805/1281268-20180509063436446-1450605939.png)

```c++
#include <stdlib.h>
#include <string.h>

#include "search.h"

/*bisearch 二分查找函数*/
int bisearch(void *sorted, const void *target, int size, int esize,
             int (*compare)(const void *key1, const void key2))
{
    int left, middle, right;
    
    /*初始化left和right为边界值*/
    left = 0;
    right = size - 1; 
    /*循环查找，直到左右两个边界重合*/
    while(left<=right)
    {
        middle = (left + right) / 2;
        switch(compare(((char *)sorted + (esize * middle)),target))
        {
        case -1: /*middle小于目标值*/
        /*移动到middle的右半区查找*/
        left = middle + 1;
        break;
        case 1:  /*middle大于目标值*/
        /*移动到middle的左半区查找*/
        right = middle - 1;
        break;
        case 0:  /*middle等于目标值*/
        /*返回目标的索引值middle*/
        return middle;
        }
    }
    /*目标未找到，返回-1*/
    return -1;
}
```

### 二分查找树

​		二叉查找树（Binary Search Tree），也称有序二叉树（ordered binary tree）,排序二叉树（sorted binary tree），是指一棵空树或者具有下列性质的二叉树：

1. 若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
2. 任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
3. 任意节点的左、右子树也分别为二叉查找树。
4. 没有键值相等的节点（no duplicate nodes）。

### 平衡二叉树

平衡二叉搜索树，又被称为AVL树，且具有以下性质：**它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。**

### B+树

![img](https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232853119-1460626460.png)

关键字个数比孩子结点个数小1，这种方式是和B树基本等价的。除此之外B+树还有以下的要求。

1）B+树包含2种类型的结点：内部结点（也称索引结点）和叶子结点。根结点本身即可以是内部结点，也可以是叶子结点。根结点的关键字个数最少可以只有1个。

2）B+树与B树最大的不同是内部结点不保存数据，只用于索引，所有数据（或者说记录）都保存在叶子结点中。

3） m阶B+树表示了内部结点最多有m-1个关键字（或者说内部结点最多有m个子树），阶数m同时限制了叶子结点最多存储m-1个记录。

4）内部结点中的key都按照从小到大的顺序排列，对于内部结点中的一个key，左树中的所有key都**小于**它，右子树中的key都**大于等于**它。叶子结点中的记录也按照key的大小排列。

5）每个叶子结点都存有相邻叶子结点的指针，叶子结点本身依关键字的大小自小而大顺序链接。

#### B+树的插入

#### B+树的删除

## 3. B+树索引

### 聚集索引

聚集索引就是按照每张表的主键构造一颗B+树，同时叶子节点存放整张表得行记录数据，因此也将聚集索引的叶子节点称为数据页，每个数据也通过双向链表进行链接。每张表只有一个聚簇索引。聚集索引能够特别快的针对范围值进行查询。

聚集索引的存储在物理上不是连续的，而是逻辑上连续的。有两点来说明：一是前面说过的页面通过双向链表链接，页面按照主键的顺序排序；另一个是页中的记录也是通过双向链表进行维护的，物理上可以同样不按照主键存储。

### 辅助索引

### 联合索引

### 覆盖索引

## 4.全文索引

### 概述

### 倒排索引

### innodb全文检索

### 全文检索